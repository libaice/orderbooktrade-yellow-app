/**
 * Prediction Market Types
 * Core types for binary outcome market with state channel integration
 */

// Outcome types for binary prediction market
export type Outcome = 'YES' | 'NO';

// Order side
export type OrderSide = 'BUY' | 'SELL';

// Order type
export type OrderType = 'LIMIT' | 'MARKET';

// Order status
export type OrderStatus = 'OPEN' | 'PARTIAL' | 'FILLED' | 'CANCELLED';

/**
 * Order in the prediction market
 */
export interface Order {
    id: string;
    userId: string;
    outcome: Outcome;
    side: OrderSide;
    type: OrderType;
    /** Price in USDC (0-1 range for binary market) */
    price: number;
    /** Number of outcome tokens */
    quantity: number;
    /** Remaining quantity after partial fills */
    remainingQuantity: number;
    /** Order creation timestamp */
    timestamp: number;
    status: OrderStatus;
}

/**
 * Fill record for a match
 */
export interface Fill {
    id: string;
    /** Maker order ID */
    makerOrderId: string;
    /** Taker order ID */
    takerOrderId: string;
    /** Fill price (maker's price) */
    price: number;
    /** Fill quantity */
    quantity: number;
    /** Timestamp of fill */
    timestamp: number;
    /** Which outcome was traded */
    outcome: Outcome;
}

/**
 * User balance in the prediction market
 */
export interface UserBalance {
    /** USDC balance */
    usdc: number;
    /** YES outcome tokens held */
    yes: number;
    /** NO outcome tokens held */
    no: number;
}

/**
 * Orderbook structure
 */
export interface Orderbook {
    /** YES outcome orders (bids on YES side) */
    yesBids: Order[];
    /** YES outcome asks (sells on YES side) */
    yesAsks: Order[];
    /** NO outcome bids */
    noBids: Order[];
    /** NO outcome asks */
    noAsks: Order[];
}

/**
 * Complete prediction market state
 * This is what gets serialized and signed for state updates
 */
export interface PredictionMarketState {
    /** Market identifier */
    marketId: string;
    /** Market question */
    question: string;
    /** Orderbook snapshot */
    orderbook: Orderbook;
    /** User balances */
    balances: Record<string, UserBalance>;
    /** Recent fills (for audit trail) */
    fills: Fill[];
    /** Monotonic state version */
    sequence: number;
    /** State timestamp */
    timestamp: number;
    /** Last trade price for YES outcome */
    lastYesPrice: number | null;
    /** Last trade price for NO outcome */
    lastNoPrice: number | null;
}

/**
 * Order request from user (before processing)
 */
export interface OrderRequest {
    userId: string;
    outcome: Outcome;
    side: OrderSide;
    type: OrderType;
    /** Price in USDC (0-1 range), required for limit orders */
    price?: number;
    /** Number of outcome tokens */
    quantity: number;
}

/**
 * Result of processing an order
 */
export interface OrderResult {
    /** Whether order was accepted */
    success: boolean;
    /** Error message if failed */
    error?: string;
    /** The order (with ID assigned) */
    order?: Order;
    /** Fills generated by this order */
    fills: Fill[];
    /** Updated state after processing */
    newState: PredictionMarketState;
}

/**
 * Aggregated price level for orderbook display
 */
export interface PriceLevel {
    price: number;
    quantity: number;
    orderCount: number;
}

/**
 * Orderbook display data
 */
export interface OrderbookDisplay {
    /** YES bids aggregated by price */
    yesBids: PriceLevel[];
    /** YES asks aggregated by price */
    yesAsks: PriceLevel[];
    /** Best YES bid price */
    bestYesBid: number | null;
    /** Best YES ask price */
    bestYesAsk: number | null;
    /** Spread (ask - bid) */
    spread: number | null;
    /** Mid price */
    midPrice: number | null;
}
